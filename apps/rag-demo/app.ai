spec is "1.0"

capabilities:
  uploads

policy
  allow ingestion.run
  allow ingestion.review
  allow ingestion.override
  allow retrieval.include_warn

record "Document":
  fields:
    document_id is text must be present
    source_name is text must be present
    upload_id is text must be present
    status is text must be present
    quality is text must be present

record "Question":
  fields:
    query is text must be present

record "Answer":
  fields:
    query is text must be present
    answer_text is text must be present
    citations is json must be present
    confidence is number must be present
    source_count is number must be present

record "ExplainSummary":
  fields:
    query is text must be present
    retrieval_mode is text must be present
    candidate_count is number must be present
    final_selection is json must be present
    ordering is text must be present
    prompt_hash is text must be present
    citation_status is text must be present
    citation_count is number must be present
    unknown_citations is json must be present

record "ExplainCandidate":
  fields:
    query is text must be present
    order is number must be present
    chunk_id is text must be present
    ingestion_phase is text must be present
    keyword_overlap is number must be present
    page_number is number must be present
    chunk_index is number must be present
    decision is text must be present
    reason is text must be present

flow "ingest_latest": requires true
  set state.ingest.status is "idle"
  set state.ingest.message is ""

  let upload_id is ""
  let has_upload is false
  try:
    let intake is state.uploads.intake
    let count is list length of intake
    if count is greater than 0:
      let last_index is count - 1
      let last_upload is list get intake at last_index
      set upload_id is last_upload.id
      set has_upload is true
  with catch err:
    set has_upload is false

  if has_upload is false:
    set state.ingest.status is "no_upload"
    set state.ingest.message is "Upload a PDF before ingesting."
    return "no_upload"

  let out is call pipeline "ingestion":
    input:
      upload_id is upload_id
    output:
      report
      ingestion
      index

  let report is map get out key "report"
  let ingestion_state is map get out key "ingestion"
  let index_state is map get out key "index"
  set state.ingestion is ingestion_state
  set state.index is index_state
  let provenance is map get report key "provenance"
  let document_id is map get provenance key "document_id"
  let source_name is map get provenance key "source_name"
  let quality is map get report key "status"

  delete "Document" where upload_id is upload_id
  set state.doc_row with:
    document_id is document_id
    source_name is source_name
    upload_id is upload_id
    status is "indexed"
    quality is quality
  if quality is "block":
    set state.doc_row.status is "blocked"
  create "Document" with state.doc_row as doc_entry

  set state.ingest.status is "ingested"
  set state.ingest.message is "Ingestion complete."
  set state.last_document_id is document_id
  set state.last_source_name is source_name
  return document_id

flow "answer_question": requires true
  set state.answer_error is ""
  set state.loading is true

  try:
    let q is input.message
  with catch err:
    set state.loading is false
    return "missing_message"
  if q is "":
    set state.loading is false
    return "empty_message"

  try:
    let existing_messages is state.chat.messages
  with catch err:
    set state.chat.messages is list:

  set state.user_msg with:
    role is "user"
    content is q
  set state.chat.messages is list append state.chat.messages with state.user_msg

  set state.question_row with:
    query is q
  create "Question" with state.question_row as question_entry

  delete "ExplainSummary" where true
  delete "ExplainCandidate" where true

  let retrieval_out is call pipeline "retrieval":
    input:
      query is q
      tier is "auto"
    output:
      report

  let retrieval_report is map get retrieval_out key "report"
  let results is map get retrieval_report key "results"
  let source_count is list length of results

  set state.result_chunk_ids is list:
  for each res in results:
    set state.result_chunk_ids is list append state.result_chunk_ids with res.chunk_id

  let offline is false
  try:
    let offline is input.offline
  with catch err:
    set offline is false

  if offline is true:
    set state.answer_text is "See sources."
    set state.answer_citations is state.result_chunk_ids
    if source_count is greater than 0:
      set state.confidence is 1
    else:
      set state.confidence is 0
    set state.source_count is source_count
  else:
    let answer_out is call pipeline "answer":
      input:
        query is q
        tier is "auto"
      output:
        report

    let answer_report is map get answer_out key "report"
    set state.answer_text is map get answer_report key "answer_text"
    set state.answer_citations is map get answer_report key "citations"
    set state.confidence is map get answer_report key "confidence"
    set state.source_count is map get answer_report key "source_count"

    try:
      let explain is map get answer_report key "explain"
      let validation is map get explain key "answer_validation"
      set state.summary_row with:
        query is q
        retrieval_mode is map get explain key "retrieval_mode"
        candidate_count is map get explain key "candidate_count"
        final_selection is map get explain key "final_selection"
        ordering is map get explain key "ordering"
        prompt_hash is map get validation key "prompt_hash"
        citation_status is map get validation key "status"
        citation_count is map get validation key "citation_count"
        unknown_citations is map get validation key "unknown_citations"
      create "ExplainSummary" with state.summary_row as explain_summary

      let candidates is map get explain key "candidates"
      set state.order_index is 0
      for each cand in candidates:
        set state.order_index is state.order_index + 1
        set state.candidate_row with:
          query is q
          order is state.order_index
          chunk_id is map get cand key "chunk_id"
          ingestion_phase is map get cand key "ingestion_phase"
          keyword_overlap is map get cand key "keyword_overlap"
          page_number is map get cand key "page_number"
          chunk_index is map get cand key "chunk_index"
          decision is map get cand key "decision"
          reason is map get cand key "reason"
        create "ExplainCandidate" with state.candidate_row as explain_candidate
    with catch err:
      set state.answer_error is "Explain bundle unavailable."

  set state.chat.citations is list:
  for each cid in state.answer_citations:
    set state.citation_row with:
      title is "Source"
      chunk_id is cid
      source_id is cid
      snippet is ""
    set state.found is false
    for each res in results:
      if state.found is false:
        if res.chunk_id is cid:
          set state.found is true
          set state.citation_row with:
            title is res.source_name
            chunk_id is res.chunk_id
            document_id is res.document_id
            page_number is res.page_number
            snippet is res.text
    set state.chat.citations is list append state.chat.citations with state.citation_row

  set state.answer_row with:
    query is q
    answer_text is state.answer_text
    citations is state.answer_citations
    confidence is state.confidence
    source_count is state.source_count
  create "Answer" with state.answer_row as answer_entry

  set state.assistant_msg with:
    role is "assistant"
    content is state.answer_text
  set state.chat.messages is list append state.chat.messages with state.assistant_msg

  set state.loading is false
  return state.answer_text

page "RAG Demo":
  title is "RAG Chat"
  text is "Upload a PDF, run ingestion, then chat."

  section "Upload PDF":
    upload intake
    button "Run ingestion":
      calls flow "ingest_latest"

  section "Chat":
    chat:
      messages from is state.chat.messages
      thinking when is state.loading
      composer calls flow "answer_question"
      citations from is state.chat.citations
